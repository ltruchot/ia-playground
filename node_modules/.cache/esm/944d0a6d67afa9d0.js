let negate,generateBool;_67a‍.x([["flipCross",()=>flipCross],["firstFalsyItem",()=>firstFalsyItem],["locateTruthyCells",()=>locateTruthyCells],["generateSquaredMatrix",()=>generateSquaredMatrix]]);_67a‍.w("./../core/functionalHelper",[["negate",["negate"],function(v){negate=v}]]);_67a‍.w("./../core/randomHelper",[["generateBool",["generateBool"],function(v){generateBool=v}]]);


       const flipCross = ([y, x]) => matrix => {
  return matrix
    .map((line, lineIdx) => (lineIdx === y ? line.map(negate) : line))
    .map((line, lineIdx) =>
      line.map((cell, idx) =>
        idx === x && lineIdx !== y ? negate(cell) : cell
      )
    );
};

       const firstFalsyItem = arr => {
  let falseItemCoords;
  arr.some((line, y) =>
    line.some((cell, x) => {
      if (!cell) {
        falseItemCoords = [y, x];
        return true;
      }
    })
  );
  return falseItemCoords;
};

       const locateTruthyCells = arr => {
  let y = 0;
  return arr.reduce((coords, line) => {
    let x = 0;
    const TruthyCells = line.reduce((cellCoords, cell) => {
      let cellCoord = [];
      if (cell) {
        cellCoord = [y, x];
        cellCoords.push(cellCoord);
      }
      x++;
      return cellCoords;
    }, []);
    y++;
    return coords.concat(TruthyCells);
  }, []);
};

       const generateSquaredMatrix = length =>
  Array.from({ length }, () => [
    ...Array.from({ length }, () => generateBool())
  ]);
